<template class='doc-view'>
    <h2 id='fixed-angularjs' @click='doScroll("angularjs")' class='canlink'>
        Angular.js
    </h2>
    <h3 id='fixed-angularjs-view-model' @click='doScroll("angularjs-view-model")' class='canlink'>
        视图和model之间的数据格式化
    </h3>
    <p>
        类似过滤器的功能，在写指令的时候，我们可能希望输入框在页面显示的是益于阅读的，而获取值的时候获取的是简洁的，因此你可能会需要在link中使用下面的方法来实现这个功能。
    </p>
    <h4>1.model到view的数据格式化：</h4>
    <pre q-code>ctrl.$formatters.unshift(function(input) {});</pre>
    <h4>2.view到model的数据格式化：</h4>
    <pre q-code>ctrl.$parsers.unshift(function(input) {});</pre>
    <p>
        上面的$formatters和$parsers就是二个队列，视图到model和model到视图，会方便经过里面定义的方法的过滤，有点类似管道流，最后流到目的地。
    </p>
    <p class="warn">
        温馨提示：别忘了设置类似require: "?ngModel"这样的语句去查找控制器。
    </p>
    <h3 id='fixed-angularjs-nosync' @click='doScroll("angularjs-nosync")' class='canlink'>
        视图和model数据不同步问题
    </h3>
    <p>
        有时候在指令里面通过jquery修改了input的数据，不过angularjs并不会知道，这时候，你有如下方法可以选择。
    </p>
    <h4>
        1.触发输入框change改变，让Angularjs发现数据改变了，从而去调用$setViewValue(value),同步数据：
    </h4>
    <pre q-code>$("input").trigger("change");</pre>
    <h4>
        2.直接手动触发同步value到viewValue和modelValue中的行为：
    </h4>
    <pre q-code>ctrl.$setViewValue($scope.info);</pre>
    <h3 id='fixed-angularjs-form-validate' @click='doScroll("angularjs-form-validate")' class='canlink'>
        表单控制
    </h3>
    <p>
        在自定义form表单的时候，或者新写一个指令来控制输入框输入的时候，为了统一控制表单输入是否合法（最后都通过$scope[表单名称]的方法来获取表单情况），你可以通过下面的方法来修改输入框是否合法：
    </p>
    <pre q-code>ctrl.$setValidity(errorType, boolean);//errorType表示错误类别，可以自定义</pre>
    <h2 id='fixed-vuejs' @click='doScroll("vuejs")' class='canlink'>
        Vue.js
    </h2>
    <h3 id='fixed-vuejs-components' @click='doScroll("vuejs-components")' class='canlink'>
        动态组件
    </h3>
    <p>
        有时候我们可能需要动态确定一个地方使用哪个组件，比如根据返回的数据确定当前是下拉还是日历组件，那就可以借助这个组件：
    </p>
    <pre q-code><component v-bind:is="yourComp"></component></pre>
    <p>
        yourComp是什么？就是一个vue组件。我们来说明一种特殊情况。
    </p>
    <pre q-code>
export default {
    template:'字符串模板'
}</pre>
    <p>
        上面的内容是写在我们自定义的组件yourComp.js中的，如何导入使用：
    </p>
    <pre q-code>import yourComp from "./yourComp";</pre>
    <p>
        像上面那样导入即可被一开始演示的component使用了。可是这样好像也没有什么特别的？
    </p>
    <p>
        那我们把yourComp.js文件稍微改造一下：
    </p>
    <pre q-code>
export default function (templateData) {
    return {
        template: '根据templateData拼接的字符串模板'
    };
};
    </pre>
    <p>
        同样，我们导入后也需要多添加一步进行处理：
    </p>
    <pre q-code>
import yourCompFactory from "./yourComp";
// 第二句可以在任意一个地方执行，包括请求回调中
yourComp=yourCompFactory(templateData);
    </pre>
    <p>
        看出来了吗？改造以后，我们就可以根据实际需要，动态调整生成的组件。
    </p>
    <h3 id='fixed-vuejs-nosync' @click='doScroll("vuejs-nosync")' class='canlink'>
        视图和model数据不同步问题
    </h3>
    <p>
        有时候在指令里面通过jquery修改了input的数据，不过Vue并不会知道，这时候，你可以通过触发输入框input事件，让Vue发现数据改变了：
    </p>
    <pre q-code>$("input").trigger("input");</pre>
</template>
<script>
    import fixedScroll from '../services/fixedScroll.js';
    export default {
        mounted() {
            this.changeActive('menu-1', 'code');
            fixedScroll(document.getElementById('root'), 44);
        },
        methods: {
            doScroll(fixedName) {
                window.location.href = (window.location.href + "").replace(/\?fixed=.*$/, '') + "?fixed=" + fixedName;
                fixedScroll(document.getElementById('root'), 44);
            }
        }
    };
</script>
<style>
    .canlink:hover {
        text-decoration: underline;
        cursor: pointer;
    }
</style>
